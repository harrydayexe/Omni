// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: post.sql

package storage

import (
	"context"
	"time"
)

const createPost = `-- name: CreatePost :exec
INSERT INTO posts (id, user_id, created_at, title, description, markdown_url) VALUES (?, ?, ?, ?, ?, ?)
`

type CreatePostParams struct {
	ID          int64     `json:"id"`
	UserID      int64     `json:"user_id"`
	CreatedAt   time.Time `json:"created_at"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	MarkdownUrl string    `json:"markdown_url"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) error {
	_, err := q.exec(ctx, q.createPostStmt, createPost,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.Title,
		arg.Description,
		arg.MarkdownUrl,
	)
	return err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = ?
`

func (q *Queries) DeletePost(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deletePostStmt, deletePost, id)
	return err
}

const findPostByID = `-- name: FindPostByID :one
SELECT id, user_id, created_at, title, description, markdown_url FROM posts WHERE id = ?
`

func (q *Queries) FindPostByID(ctx context.Context, id int64) (Post, error) {
	row := q.queryRow(ctx, q.findPostByIDStmt, findPostByID, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.Title,
		&i.Description,
		&i.MarkdownUrl,
	)
	return i, err
}

const getUserAndPostsByIDPaged = `-- name: GetUserAndPostsByIDPaged :many
SELECT users.id, users.username, posts.id, posts.user_id, posts.created_at, posts.title, posts.description, posts.markdown_url FROM users 
LEFT JOIN posts ON users.id = posts.user_id
WHERE users.id = ? AND posts.created_at > ? 
ORDER BY posts.created_at ASC
LIMIT ?
`

type GetUserAndPostsByIDPagedParams struct {
	ID           int64     `json:"id"`
	CreatedAfter time.Time `json:"created_after"`
	Limit        int32     `json:"limit"`
}

type GetUserAndPostsByIDPagedRow struct {
	ID       int64  `json:"id"`
	Username string `json:"username"`
	Post     Post   `json:"post"`
}

func (q *Queries) GetUserAndPostsByIDPaged(ctx context.Context, arg GetUserAndPostsByIDPagedParams) ([]GetUserAndPostsByIDPagedRow, error) {
	rows, err := q.query(ctx, q.getUserAndPostsByIDPagedStmt, getUserAndPostsByIDPaged, arg.ID, arg.CreatedAfter, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAndPostsByIDPagedRow
	for rows.Next() {
		var i GetUserAndPostsByIDPagedRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Post.ID,
			&i.Post.UserID,
			&i.Post.CreatedAt,
			&i.Post.Title,
			&i.Post.Description,
			&i.Post.MarkdownUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePost = `-- name: UpdatePost :exec
UPDATE posts SET title=?, description=?, markdown_url=? WHERE id=?
`

type UpdatePostParams struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	MarkdownUrl string `json:"markdown_url"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) error {
	_, err := q.exec(ctx, q.updatePostStmt, updatePost,
		arg.Title,
		arg.Description,
		arg.MarkdownUrl,
		arg.ID,
	)
	return err
}
